<!-- TOC -->

- [堆和堆排序](#堆和堆排序)
    - [如何理解“堆”](#如何理解堆)
    - [如何实现一个堆？](#如何实现一个堆)
        - [如何存储一个堆？](#如何存储一个堆)
        - [堆支持那些操作？](#堆支持那些操作)
            - [往堆中插入一个元素](#往堆中插入一个元素)
            - [从堆顶删除一个元素](#从堆顶删除一个元素)
    - [如何实现堆排序](#如何实现堆排序)

<!-- /TOC -->

## 堆和堆排序

### 如何理解“堆”

堆是一种特殊的二叉树。堆又一下特点

- 堆是一个完全二叉树
- 堆中每个节点的值都必须大于等于（或者小于等于）其他子树中每个节点值。也可以等价为“堆中每个节点值都大于等于（或者小于等于）其左右节点的值”。

堆可以分为：
- 大顶堆（每个节点值都大于等于子树中的每个节点的值）
- 小顶堆（每个节点值都小于等于子树中的每个节点的值）

![image](image/堆.jpg)

其中第一个和第二个是大顶堆，第三个是小顶堆，第四个不是堆。除此之外，从图中还可以看出来，对于同一组数据，我们可以构建多种不同形态的堆。

### 如何实现一个堆？

要实现一个堆，要知道*堆支持哪些操作*以及*如何存储一个堆*

#### 如何存储一个堆？

由堆一颗完全树，所以可以使用数组存储堆是非常节省存储空间的

#### 堆支持那些操作？

##### 往堆中插入一个元素

往堆中插入元素后，需要满足堆的两个特性。

如果我们把新插入的元素放到堆的最后，你可以看我画的这个图，是不是不符合堆的特性了？于是，我们就需要进行调整，让其重新满足堆的特性，这个过程我们起了一个名字，就叫作**堆化**

堆化实际上有两种，从下往上和从上往下。这里我先讲从下往上的堆化方法。

![image](image/向上堆化.jpg)

##### 从堆顶删除一个元素

从堆的定义的第二条中，任何节点的值都大于等于（或小于等于）子树节点的值，我们可以发现，堆顶元素存储的就是堆中数据的最大值或者最小值。

假设构造的是大顶堆，堆顶元素就是最大的元素。当我们删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。

![iamge](image/向下堆化.jpg)

实际上，稍微改变一下思路，就可以解决这个问题。看下面这幅图。把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是从上往下的堆化方法。

![image](image/向下堆化1.jpg)

一个包含n 个节点的完全二叉树，树的高度不会超过 log<sub>2</sub>n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 O(log n)。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 (log n)。

### 如何实现堆排序